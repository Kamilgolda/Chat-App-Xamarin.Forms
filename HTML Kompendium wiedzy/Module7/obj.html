<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <h2>Tworzenie prostych obiektów</h2>
    <img src="img/obj.png" style="float:right" />

    <code>let employee1 = new Object();</code>
    <h4>
        Ta instrukcja tworzy obiekt bez
        właściwości i bardzo ograniczona funkcjonalność (tylko
        ma metody dostarczone przez typ obiektu),
        i przypisuje obiekt do zmiennej o nazwie
        employee1. Możesz użyć zmiennej employee1
        aby uzyskać dostęp do obiektu.
    </h4>
    <h3>
        Prostszym sposobem utworzenia obiektu jest użycie nawiasów klamrowych {}. Poniższy przykład jest semantycznie równoważny
        pierwszy przykład:
    </h3>
    <code>
        let employee2 = {};
    </code>
    <hr />
    <h2>Dodawanie właściwości do obiektu</h2>
    <h3>
        Puste obiekty nie są zbyt przydatne, więc JavaScript umożliwia dodawanie właściwości do obiektu za pomocą
        następująca składnia:
    </h3>
    <code>
        objectReference.propertyName = value;

    </code>
    <h3>Dodawanie metod</h3>
    <textarea rows="10" cols="100">
let employee1 = {};
employee1.name = "John Smith";
employee1.age = 21;
employee1.salary = 10000;
employee1.payRise = function(amount) {
// Inside a method, "this" means the current object.
this.salary += amount;
return this.salary;
}

</textarea>

    <hr />
    <h2>Dostęp do właściwości obiektu</h2>
    <h3>
        Aby uzyskać dostęp do właściwości lub wywołać metodę na obiekcie, użyj następującej składni:
    </h3>
    <code>
        objectReference.propertyName = value;<br />
        objectReference.functionName(parameters);
    </code>
    <br />
    <br />
    <code>
        let newSalary = employee1.payRise(1000);<br />
        document.write("New salary for employee1 is " + newSalary);
    </code>
    <hr />
    <h2>Korzystanie z Object Literal Notation</h2>
    <img src="img/obj2.png" style="float:right" />
    <h3>
        Notacja dosłowna obiektu stanowi skrótowy sposób
        aby zdefiniować obiekt i ustawić jego właściwości. Obiekt
        notacja literalna ma następującą składnię:
    </h3>
    <code>
        const objectName = {<br />
        property1: value1,<br />
        property2: value2,<br />
        ...<br />
        };
    </code>
    <br /><br />
    <code>
        const employee1 = {<br />
        name: "John Smith",<br />
        age: 21,<br />
        salary: 10000<br />
        };
    </code>
    <br /><br />
    <code>
        const employee2 = {<br />
        name: "Mary Jones",<br />
        age: 42,<br />
        salary: 20000,<br />
        payRise: function(amount) {<br />
        this.salary += amount;<br />
        return this.salary;<br />
        },<br />
        displayDetails: function() {<br />
        alert(this.name + " is " + this.age + " and earns " + this.salary);<br />
        }<br />
        };
    </code>
    <hr />
    <h2>
        Uzywanie konstruktorów
    </h2>
    <img src="img/constr.png" style="float:right" />
    <code>
        const Account = function (id, name) {<br />
        this.id = id;<br />
        this.name = name;<br />
        this.balance = 0;<br />
        this.numTransactions = 0;<br />
        };
    </code>
    <h3>
        Po zdefiniowaniu funkcji konstruktora możesz użyć konstruktora do utworzenia nowego obiektu przez
        za pomocą nowego słowa kluczowego. Możesz przekazać parametry do funkcji konstruktora, aby określić wartości początkowe
        dla obiektu. Podczas tworzenia obiektu za pomocą nowego słowa kluczowego JavaScript wykonuje następujące czynności
    </h3>
    <h4>
        1. Tworzy nowy obiekt.<br />
        2. Ustawia właściwość konstruktora nowego obiektu na odwołanie do funkcji konstruktora.<br />
        3. Przypisuje to do odniesienia do nowego obiektu.<br />
        4. Wywołuje kod w funkcji konstruktora nowego obiektu, aby ustawić właściwości obiektu<br />
    </h4>
    <code>
        let acc1 = new Account(1, "John");<br />
        let acc2 = new Account(2, "Mary");
    </code>
    <hr />
    <h2>Używanie Prototypów</h2>
    <h3>
        Prototypy umożliwiają dzielenie funkcji między obiektami utworzonymi przy użyciu tego samego konstruktora. Wszystko
        Obiekty JavaScript, w tym funkcje konstruktora, mają specjalną właściwość o nazwie prototype. The
        prototyp to tak naprawdę kolejny obiekt, do którego można przypisać nowe właściwości i metody; używasz go jako
        plan tworzenia nowych obiektów.
    </h3>
    <h3>
        Poniższy przykład ustawia prototyp funkcji konstruktora konta pokazanej w poprzednim
        temat. W przykładzie dodano metody wdrażania zachowania konta bankowego:
    </h3>
    <textarea cols="100" rows="20">
Account.prototype = {
deposit: function(amount) {
this.balance += amount;
this.numTransactions++;
},
withdraw: function(amount) {
this.balance -= amount;
this.numTransactions++;
},
displayDetails: function() {
alert(this.id + ", " +
this.name + " balance $" +
this.balance + " (" +
this.numTransactions + " transactions)");
}
};
</textarea>
    <img src="img/prot.png" style="float:right" />

    <h3>
        nowy obiekt ma dostęp do wszystkich właściwości zdefiniowanych w funkcji konstruktora i wszystkich właściwości zdefiniowanych przez prototyp dla
        funkcja konstruktora. Jednak właściwości zdefiniowane przez prototyp są wspólne dla wszystkich instancji
        obiekt.
    </h3>
    <h3>
        Poniższy przykład tworzy niektóre obiekty przy użyciu funkcji Account constructor function i ilustruje
        jak można wywoływać metody zdefiniowane w prototype object funkcji Account constructor.
        Należy pamiętać, że właściwości danych zdefiniowane w Account constructor (id, name,
        balance, and numtransactions) są specyficzne dla każdego obiektu (acc1 i acc2), podczas gdy metody
        zdefiniowane przez prototyp (deposit, display, and withdraw) są wspólne dla wszystkich instancji. Ten obiekt
        używane przez te funkcje odwołuje się do odpowiedniej instancji:
    </h3>
    <code>
        let acc1 = new Account(1, "John");<br />
        let acc2 = new Account(2, "Mary");<br />
        acc1.deposit(100);<br />
        acc1.displayDetails();<br />
        acc2.withdraw(50);<br />
        acc2.displayDetails();
    </code>
    <hr />
    <h2>Korzystanie z metody Object.create()</h2>
    <img src="img/create.png" style="float:right" />
    <h3>
        Object ma metodę create (), która
        umożliwia utworzenie obiektu na podstawie
        istniejący prototyp i opcjonalnie zapewni
        dodatkowe właściwości. Ta funkcja umożliwia
        wdrożyć wydajną formę dziedziczenia
        na prototypach.
    </h3>
    <code>
        Object.create(prototypeObject,
        propertiesObject)
    </code>

    <h4>
        prototypeObject określa
        obiekt do użycia jako prototyp nowego obiektu. Możesz wywołać Object.getPrototypeOf()
        , jeśli chcesz uzyskać prototyp istniejącego obiektu do użycia tutaj.
    </h4>
    <h4>
        propertiesObject jest opcjonalny i określa obiekt, którego właściwości zostaną dodane
        do nowego obiektu.
    </h4>

    <h3>
        Poniższy przykład tworzy obiekt przy użyciu prototypu null i dodaje dwie proste właściwości
    </h3>
    <code>
        let obj1 = Object.create(null, {<br />
        prop1: {value: "hello", writable: true}, // read/write property<br />
        prop2: {value: "world" } // read-only property<br />
        });
    </code>
    <h4>
        Następny przykład tworzy obiekt o nazwie obj2 przy użyciu prototypu obiektu acc1 zdefiniowanego w
        wcześniejszych przykładach
    </h4>
    <code>
        // Account constructor function, same as before.<br />
        const Account = function (id, name) { ... };<br />
        // Account prototype, same as before.<br />
        Account.prototype = { ... };<br />
        acc1 = new Account(...);<br />
        // Create an object by using the Account prototype.<br />
        let obj2 = Object.create(Object.getPrototypeOf(acc1));
    </code>
    <hr />
    <h2>Korzystanie z klas ES2015</h2>
    <img src="img/class.png" style="float:right" />
    <h3>
        Klasy ES2015
        mają podobną składnię do definicji klasy w
        języki takie jak C # i Java, ale pod
        kaptur są zasadniczo różne i
        zaimplementuj ten sam obiektowy obiekt JavaScript
        model wyjaśniony w poprzednich tematach.
    </h3>
    <code>
        class Account {<br />
        constructor (id, name) {<br />
        this.id = id;<br />
        this.name = name;<br />
        this.balance = 0;<br />
        this.numTransactions = 0;<br />
        }<br />
        }
    </code>
    <h3>
        Klasa konta zdefiniowana powyżej jest jedynie skróconą składnią w stosunku do funkcji konstruktora konta
        zdefiniowane na poprzednich lekcjach. Podobnie jak w przypadku funkcji konstruktora, możemy teraz utworzyć konto
        wystąpienie przy użyciu new.
    </h3>
    <code>
        let acc1 = new Account(1, "John");<br />
        let acc2 = new Account(2, "Mary");
    </code>
    <h3>
        Ciało klasy jest częścią nawiasów klamrowych. Metody są w rzeczywistości funkcjami zdefiniowanymi we właściwości prototypu
        obiektu, jak opisano we wcześniejszych lekcjach.
    </h3>
    <h3>
        Poniższy przykład pokazuje, jak dodać metody do naszej klasy konta:
    </h3>
    <textarea rows="25"cols="100">
class Account {
constructor (id, name) {
this.id = id;
this.name = name;
this.balance = 0;
this.numTransactions = 0;
}
deposit(amount) {
this.balance += amount;
this.numTransactions++;
}
withdraw(amount) {
this.balance -= amount;
this.numTransactions++;
}
displayDetails() {
alert(this.id + ", " +
this.name + " balance $" +
this.balance + " (" +
this.numTransactions + " transactions)");
}
}
</textarea>

    <h3>
        deposit, withdraw and displayDetails są ostatecznie przypisywane jako właściwości do prototypu konta
        obiekt i możemy je wywoływać tak jak wcześniej.
    </h3>
    <code>
        let acc1 = new Account(1, "John");<br />
        let acc2 = new Account(2, "Mary");<br />
        acc1.deposit(100);<br />
        acc1.displayDetails();<br />
        acc2.withdraw(50);<br />
        acc2.displayDetails();
    </code>
</body>
</html>