<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <h2>Wdrażanie enkapsulacji</h2>
    <img src="img/enc.png" style="float:right" />
    <h3>
        Javascript używa techniki znanej jako closures to
        achieve encapsulation.
    </h3>
    <h3>
        Zamknięcia umożliwiają definiowanie enkapsulowanych zmiennych dla obiektu i eksponowanie zmiennych za pomocą zestawu
        funkcji publicznego dostępu. Aby zaimplementować zamknięcia, zdefiniuj funkcję konstruktora i dodaj następujące elementy
    </h3>
    <h4>
        1.Deklaruj zmienne bez użycia this. Brak tego słowa kluczowego oznacza, że
        zmienne mają zasięg lokalny i są widoczne tylko w funkcji konstruktora.<br />
        2.Zadeklaruj metody pobierania i ustawiania wartości zmiennych. Podczas deklarowania użyj this, aby upewnić się, że są widoczne dla kodu zewnętrznego.
    </h4>
    <h3>
        Poniższy przykład pokazuje, jak używać zamknięć, aby uzyskać enkapsulację. Zmienne nazwy i wieku
        są w zasadzie prywatne dla obiektów Person, podczas gdy getName (), getAge (), setName () i setAge ()
        metody są publiczne.
    </h3>
    <textarea cols="150" rows="40">
const Person = function(name, age)
{
// Private properties.
let _name, _age;
// Public methods defined in the constructor have access to private properties.
this.getName = function()
{
return _name;
}
this.setName = function(name)
{
_name = name;
}
this.getAge = function()
{
return _age;
}
this.setAge = function(age)
{
if (age > 0 && age < 100)
_age = age;
}
// Constructor logic.
_name = name;
this.setAge(age);
}
// Public methods defined in the prototype do not have access to private properties.
Person.prototype =
{
toString: function()
{
return this.getName() + " is " + this.getAge();
}
}
// External code.
const person1 = new Person("Joe", 21);
alert(person1.toString()); // Displays "Joe is 21"
alert(person1._name); // Displays "undefined"
</textarea>
    <hr />
    <h2>Wdrażanie dziedziczenia przez łączenie prototypów</h2>
    <img src="img/dz.png" style="float:right" />
    <h3>
        W
        JavaScript, implementujesz dziedziczenie poprzez zdefiniowanie
        obiekt, który rozszerza istniejący obiekt.
    </h3>
    <h3>
        Możesz użyć kilku języków JavaScript
        mechanizmy wdrażania dziedziczenia. Możesz
        użyj funkcji Object.create, aby zaimplementować
        forma dziedziczenia, która obsługuje funkcje współdzielone
        i dane instancji.
    </h3>
    <h4>
        1. Zdefiniuj konstruktor podstawowy i prototyp.<br />
        2. Zdefiniuj konstruktor pochodny.<br />
        3. Ustaw właściwość prototypu konstruktora pochodnego jako instancję obiektu podstawowego. To
        zapewnia, że ​​obiekt pochodny ma dostęp do wszystkich elementów zdefiniowanych w prototypie podstawowym.<br />
        4. Zresetuj właściwość konstruktora w wyprowadzonym prototypie, aby odwoływał się z powrotem do wyprowadzonego
        konstruktor.
    </h4>
    <h3>
        Poniższy przykład pokazuje, jak zaimplementować dziedziczenie w JavaScript za pomocą łączenia prototypów
    </h3>
    <textarea rows="30" cols="150">
// Base constructor.
const Person = function(name, age) {
this.name = name;
this.age = age;
}
// Base prototype.
Person.prototype = {
haveBirthday: function() {
this.age++;
}
};
// Derived constructor.
const Student = function(name, age, subject) {
this.name = name;
this.age = age;
this.subject = subject;
}
// Set the derived prototype to be the same object as the base prototype,
// and reset that derived prototype so that it uses the correct constructor.
Student.prototype = new Person();
Student.prototype.constructor = Student;
// Create a derived object and invoke any methods defined in the object or one of its
// parents. JavaScript uses prototype chaining to locate methods up the inheritance tree.
let aStudent = new Student("Jim", 20, "Physics");
aStudent.subject = "BioChemistry";
aStudent.haveBirthday();
alert(aStudent.age);
</textarea>
    <hr />
    <h2>Implementacja dziedziczenia w klasach ES2015</h2>
    <img src="img/cl2.png" style="float:right" />
    <h3>
        podczas definiowania class
        możemy zdefiniować dziedziczenie za pomocą
        extends, po którym następuje obiekt podstawowy. Na
        ważnym dodatkiem w klasie ES2015 jest super
        , które służy do wywołania klasy podstawowej
        konstruktor lub odpowiednie metody.
        Poniższy przykład pokazuje, jak zaimplementować
        dziedziczenie w klasach ES2015.
    </h3>
    <textarea rows="25" cols="150">
// Base class.
class Person {
constructor(name, age) {
this.name = name;
this.age = age;
}
haveBirthday() {
this.age++;
}
}
// Derived class.
class Student extends Person {
constructor(name, age, subject) {
super(name,age);
this.subject = subject;
}
}
// Create a derived object and invoke any methods defined in the object or one of its
// parents. JavaScript uses prototype chaining to locate methods up the inheritance tree.
let aStudent = new Student("Jim", 20, "Physics");
aStudent.subject = "BioChemistry";
aStudent.haveBirthday();
alert(aStudent.age);
</textarea>
    <hr />
    <h2>
        Dodanie funkcjonalności do istniejących obiektów
    </h2>
    <img src="img/obj3.png" style="float:right" />
    <h3>
        Możesz użyć prototypów do rozszerzenia
        funkcjonalność istniejących obiektów, w tym
        obiekty wbudowane zdefiniowane jako część standardu
        Język JavaScript.s
    </h3>
    <h3>
        Aby rozszerzyć funkcjonalność obiektu, wykonaj następujące czynności
        te kroki:<br />
        • Zdobądź prototyp obiektu.<br />
        • Przypisz nową właściwość do obiektu, do
        reprezentują nową funkcję, którą chcesz
        dodać.
    </h3>
    <h3>
        Poniższy przykład pokazuje, jak dodać funkcjonalność do istniejącego obiektu. Kod definiuje a
        funkcja konstruktora o nazwie Point, reprezentująca punkt współrzędnych o właściwościach x y. Kod
        następnie dodaje metody o nazwach moveBy() i moveTo() do prototypowego obiektu Point i pokazuje, jak te
        metody te są dostępne we wszystkich obiektach Point.
    </h3>
    <textarea rows="20" cols="150">
const Point = function(x, y) {
this.x = x;
this.y = y;
}
Point.prototype.moveBy = function(deltaX, deltaY) {
this.x += deltaX;
this.y += deltaY;
}
Point.prototype.moveTo = function(otherPoint) {
this.x = otherPoint.x;
this.y = otherPoint.y;
}
const p1= new Point(100, 200);
p1.moveBy(10, 20);
const p2= new Point(25, 50);
p2.moveTo(p1);
alert("p2.x: " + p2.x + " p2.y: " + p2.y);
</textarea>
    <hr />
    <h2>Korzystanie z metody Zastosuj z funkcjami ogólnymi</h2>
    <h3>
        Oprócz zdefiniowania prototypu, który jest specyficzny dla danego typu, możesz także tworzyć funkcje ogólne, które sam wybierzesz
        można użyć do implementacji wspólnej funkcjonalności dla obiektów prawie dowolnego typu. Rozważ następujące proste
        funkcja globalna, która ustawia właściwość koloru obiektu na wartość określoną jako parametr:
    </h3>
    <code>
        function SetColor(color) {<br />
        this.color = color;<br />
        }
    </code>
    <h3>
        Poniższy przykład pokazuje, jak wywołać
        Metoda SetColor dla obiektu Point, jak zdefiniowano w poprzednim przykładzie kodu w tym temacie:
    </h3>
    <code>
        const p1= new Point(100, 200);<br />
        ...<br />
        SetColor.apply(p1, ["red"]);<br />
        alert(p1.color); // Displays "red"
    </code>
</body>
</html>