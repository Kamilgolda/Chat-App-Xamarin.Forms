<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <img src="img/var.png" style="float:right" />
    <h2>Określanie i podnoszenie zakresu </h2>
    <h3>
        var
        w JavaScript ma jeden z dwóch zakresów:
    </h3>
    <ul>
        <li>
            <h4>
                Zmienna ma zasięg globalny, jeśli została zdefiniowana
                poza funkcją.
            </h4>
        </li>
        <li>
            <h4>
                Zmienna ma zasięg funkcji, jeśli jest zdefiniowany w funkcji.
            </h4>
        </li>
    </ul>
    <h3>Zmienne o zasięgu blokowym są definiowane za pomocą słów kluczowych let lub const. i są widoczne w podblokach</h3>
    <textarea cols="150" rows="18">
    <script>
        const num1 = 7; //zmienna globalna i przypisanie jej 7
        function demonstrateScopingAndHoisting() {
            if (true) {
                const num1 = 42; //zmienna lokalna
                let num2 = 43; //zmienna lokalna
            }
            alert("The value of num1 is " + num1); //widzi nadal tą z ifa
            try {
                alert("The value of num2 is " + num2); //tutaj num2 nie jest widoczna
            }
            catch (err) {
                alert("num2 is not defined");
            }
        }
        demonstrateScopingAndHoisting();
</script>
</textarea>
    <h4>
        Czyli var tworzy zmienną widoczną globalnie, też poza blokami i powinno się jej używać tylko gdy jest potrzebna. Zaleca się stosowanie let i const.
    </h4>

    <textarea cols="100" rows="10">
const elem = document.querySelector(“input”);
let count = 1;
if( … ){
count+=1;
}
else{
elem = null // this will throw an exception
}
</textarea>

    <h2>Zarządzanie globalną przestrzenią nazw</h2>
    <img src="img/names.png" style="float:right" />

    <h3>
        JavaScript udostępnia kilka mechanizmów, które pomagają unikać globalnych konfliktów nazw, w tym:<br />
        • Natychmiastowe wywołanie funkcji - funkcje anonimowe function ()<br />
        • Przestrzenie nazw<br />
        • Strict mode
    </h3>
    <h3>
        ECMA-262 6th edition wprowadziła jeszcze dwie funkcje, które mogą pomóc w zarządzaniu globalnym
        przestrzenią nazw;<br />
        • Zmienne o zasięgu blokowym - omówione w poprzedniej lekcji.<br />
        • Moduł - omówiony w następnym temacie.
    </h3>

    <h2>Przestrzenie nazw</h2>
    <textarea rows="12" cols="50">
const MyNamespace = {
myFunction1: function(someParameters) {
// Implementation code…
},
myFunction2: function(someParameters) {
// Implementation code…
},
message: "Hello World",
count: 42
}
</textarea>
    <h3>dostęp do elementów przestrzeni nazw:</h3>
    <code>
        MyNamespace.myFunction1(someParameterValues);<br />
        MyNamespace.message = "Goodbye all";
    </code>
    <hr />
    <h2>Strict Mode</h2>
    <h3>tworząc zmienną bez podania var/const/let tworzy się domyślnie var czyli zmienna globalna</h3>
    <h3>Aby uniknąć przypadkowego zadeklarowania zmiennych globalnych poprzez pominięcie słowa kluczowego var, możesz użyć strict mode:</h3>
    <code>
        function someFunction() {<br />
        "use strict";<br />
        // Other statements.<br />
        }
    </code>

    <h2>Moduły</h2>
    <h3>
        Moduły są samodzielne i implementują
        odrębna funkcjonalność pozwalająca na
        w razie potrzeby zaktualizowanie, dodanie lub usunięcie, bez
        zakłócania całego systemu. Łamanie kodu
        w moduły zwiększa łatwość konserwacji i
        możliwość ponownego użycia kodu.
        Moduły są zapisywane w plikach. Jeden moduł
        na plik i jeden plik na moduł.
    </h3>
    <h3>
        Aby załadować plik JavaScript jako moduł, musimy dodać tag script z atrybutem type, którego wartość to
        module.
    </h3>
    <textarea cols="100">
    <script src="mymodule.js" type="module"></script>
</textarea>
    <h4>Moduły mają kilka kluczowych różnic w stosunku do zwykłych plików skryptów</h4>
    <img src="img/mod.png" />

    <h3>
        Ujawnienie interfejsu API z modułu odbywa się jawnie przy użyciu deklaracji eksport, natomiast
        wykorzystanie interfejsów API modułu zostanie wykonane za pomocą deklaracji import.
    </h3>
    <h3>dwa rodzaje eksportu:</h3>
    <ul>
        <li>
            <h3>
                Nazwany eksport
                Moduł może eksportować wiele funkcji, poprzedzając je deklaracją eksportową.
            </h3>
            <textarea rows="15" cols="100">
//------ calc.js ------
export function sum(x,y) {
return x + y;
}
export function multiply(x, y) {
return x * y;
}
//------ main.js ------
import { sum, multiply } from 'calc.js';
console.log(sum(4,4)); // 8
console.log(multiply(5,2)); // 10
</textarea>
            <h4>
                Moduł można również zaimportować jako całość, a jego nazwane eksporty zostaną skierowane przy użyciu
                property notation.
            </h4>
            <code>
                //------ main.js ------<br />
                import * as calc from 'calc.js';<br />
                console.log(calc.sum(4,4)); // 8<br />
                console.log(calc.multiply(5,2)); // 10
            </code>
        </li>

        <li>
            <h3>Domyślny eksport, Moduł może zdefiniować pojedynczy domyślny eksport, główną eksportowaną wartość.</h3>
            <textarea rows="10" cols="100">
//------ sum.js ------
export default function sum(x,y) {
return x + y;
}
//------ main.js ------
import sumFunc from 'sum.js';
console.log(sumFunc(4,4)); // 8
</textarea>
        </li>
    </ul>
    <hr />
    <h2>
        Obiekty singletonowe i funkcje globalne w JavaScript
    </h2>
    <img src="img/sinletone.png" style="float:right" />
    <h3>
        Wzór singletonu opisuje, jak to zapewnić
        że istnieje tylko jedna instancja klasy
        Typowe zastosowania wzoru singletonu
        może obejmować następujące klasy:
    </h3>
    <h4>
        Database driver manager class
        odpowiedzialny za wybór bazy danych
        sterownik do użycia w celu otwarcia połączenia z
        Baza danych.
    </h4>
    <h4>
        screen manager class za którą odpowiada
        organizowanie układu okien w jednym
        ekranie.
    </h4>
    <h4>Klasa matematyczna zapewniająca funkcje algebraiczne i trygonometryczne, takie jak sin, cos i tan</h4>
    <h4>
        Obiekt Math udostępnia funkcje matematyczne i stałe. Dostęp do tych funkcji i
        stałe wartości bezpośrednio przez obiekt Math; nie tworzysz najpierw obiektu matematycznego. The
        poniższy przykład pokazuje, jak uzyskać dostęp do niektórych członków obiektu Math:
    </h4>
    <code>
        let radius = 100 * Math.random();<br />
        let circumference = 2 * Math.PI * radius;<br />
        let area = Math.PI * Math.pow(radius, 2);<br />
    </code>
    <h4>
        Obiekt JSON zapewnia metody konwertowania wartości na JavaScript Object Notation (JSON)
        ciągi oraz do konwersji ciągów JSON z powrotem na wartości. Poniższy przykład pokazuje, jak korzystać z
        Obiekt JSON:
    </h4>
    <code>
        let anObject;<br />
        ...<br />
        let anObjectAsJsonString = JSON.stringify(anObject);<br />
        let anObjectAgain = JSON.parse(anObjectAsJsonString);
    </code>

    <h3>
        JavaScript zapewnia również zestaw globalnych wspólnych funkcji i właściwości, których można używać ze wszystkimi
        wbudowane obiekty JavaScript, takie jak parseInt (), parseFloat () i isNan (). Poniższy przykład pokazuje
        jak korzystać z tych globalnych funkcji:
    </h3>
    <code>
        let ageEnteredByUser;<br />
        let heightEnteredByUser;<br />
        …<br />
        let age = parseInt(ageEnteredByUser);<br />
        let height = parseFloat(heightEnteredByUser);<br />
        if (isNan(age) || isNan(height))<br />
        alert("Invalid input");
    </code>





    <script>


    </script>


</body>
</html>