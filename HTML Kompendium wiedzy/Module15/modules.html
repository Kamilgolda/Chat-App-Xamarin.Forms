<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <h1>Moduły</h1>
    <h3>
        Dzięki CommonJS każdy plik JavaScript ma własny kontekst modułu, a jego funkcjonalność jest generowana, gdy
        za pomocą polecenia eksportu. Inne pliki używają wymaganej komendy do załadowania modułu.
        Podczas definiowania modułu CommonJS może on wyglądać mniej więcej tak:
        Poniższy przykład pokazuje, jak zdefiniować moduł CommonJS:
    </h3>
    <textarea rows="20" cols="80">
/app/myModule/myModule.js
function myModule() {
this.sayHello = function() {
return 'hello!';
}
this.foo = function() {
return '1234!';
}
}
module.exports = myModule;

Poniższy przykład pokazuje, jak załadować moduł CommonJS:

/app/main.js
var myModule = require('myModule');
var myModuleInstance = new myModule();
myModuleInstance.sayHello(); // 'hello!'
myModuleInstance.foo(); // 1234!'
</textarea>
    <h3>
        System modułowy CommonJS dokonuje przejścia na pliki .js i znajduje zdania eksportowe, aby wiedzieć, co my
        chcę ujawnić. Kiedy chcemy użyć myModule w innych plikach, musimy wywołać go z wymaganym
        polecenie, a następnie CommonJS wie, aby załadować moduł.
    </h3>
    <h2>AMD</h2>
    <h3>
        AMD stosuje podejście oparte na pierwszej przeglądarce i zachowanie asynchroniczne, aby wykonać zadanie. Ładowanie
        moduły korzystające z AMD wyglądają mniej więcej tak:
        Poniższy przykład pokazuje, jak zdefiniować i załadować moduł AMD:
    </h3>
    <textarea rows="17" cols="80">
/app/main.js
define(['myModule', 'myOtherModule'], function(myModule, myOtherModule) {
console.log(myModule.hello());
});
/app/myModule/myModule.js
define([], function() {
return {
sayHello: function() {
console.log('hello');
},
foo: function() {
console.log('1234!');
}
};
});
</textarea>
    <h3>
        Funkcja define jej pierwszy argument tablicę zależności każdego modułu. Te
        zależności są ładowane w tle (w sposób nieblokujący), a po załadowaniu definiują wywołania
        podana funkcja callback. callback przyjmuje zależności, które zostały załadowane jako
        argumenty. Wreszcie, same zależności muszą być również zdefiniowane przy użyciu słowa kluczowego define.
    </h3>
    <hr />
    <h2>Node.js</h2>
    <h3>
        Node.js uruchamia asynchroniczne programowanie jednowątkowe, nieblokujące, które jest bardzo pamięcią
        wydajny.
        Poniższy przykład pokazuje kod w Node.js, który tworzy serwer WWW na porcie 80 i zwraca
        "Witaj świecie":
    </h3>
    <textarea rows="8" cols="80">
var http = require('http');
http.createServer(function (req, res) {
res.writeHead(200, {'Content-Type': 'text/html'});
res.end('Hello World!');
}).listen(8080);
</textarea>
    <h3>
        Aby uruchomić program Node.js, otwórz terminal, przejdź do folderu zawierającego program główny
        plik, a następnie uruchom polecenie node, a następnie nazwę pliku.
    </h3>
    <h3>Program npm jest instalowany na twoim komputerze podczas instalacji Node js.</h3>
    <h3>
        Jeśli chcesz użyć modułu z npm, musisz zainstalować moduł z npm. Otwórz terminal,
        przejdź do folderu aplikacji, a następnie wpisz npm install &lt;nazwa_modułu&gt;.
    </h3>
    <h3>Poniższy przykład pokazuje, jak używać upper-case package in node code:</h3>

    <textarea rows="8" cols="60">
var http = require('http');
var uc = require('upper-case');
http.createServer(function (req, res) {
res.writeHead(200, {'Content-Type': 'text/html'});
res.write(uc("Hello World!"));
res.end();
}).listen(8080);
</textarea>
    <h3>
        Narzędzia takie jak webpack i Babel są oparte na Node.js i obsługują zainstalowane zależności innych firm
        poprzez npm, dodatkowo możesz użyć package.json do zarządzania zależnościami twojego projektu i uruchamiania
        różne skrypty budowania, aby utworzyć pakiet aplikacji.
    </h3>
</body>
</html>