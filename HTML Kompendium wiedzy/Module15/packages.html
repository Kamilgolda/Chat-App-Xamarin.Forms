<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <h1>Konfiguracja webpacka</h1>
    <h3>
        Aby zbudować pakiet zależności, webpack działa
        kod rekurencyjnie. W następnym etapie webpack
        ładuje każdy moduł w aplikacji i pakuje wszystkie
        je w jeden lub więcej pakietów.
    </h3>
    <h2>Entry</h2>
    <h3>
        entry point wskazuje, który moduł webpack
        powinien użyć, aby rozpocząć budowanie swojego wewnętrznego
        wykres zależności. Po wejściu do entry point
        webpack obliczy moduły i biblioteki
        od których zależy entry point (bezpośrednio i
        pośrednio).
    </h3>
    <h2>Output</h2>
    <h3>
        output property wskazuje webpackowi, gdzie ma emitować bundles i jak je nazwać
 W poniższym przykładzie używamy pakietu ścieżki do opublikowania pliku w nowym folderze o nazwie dist.
    </h3>
    <h2>Loaders (rules)</h2>
    <h3>
        Loaders umożliwiają webpackowi przetwarzanie więcej niż tylko plików JavaScript (sam webpack tylko rozumie
        JavaScript). Dają ci możliwość wykorzystania możliwości tworzenia pakietów w pakiecie dla wszystkich rodzajów plików
        konwertując je na prawidłowe moduły, które może przetwarzać webpack.<br/>
        Programy ładujące mają dwa specjalne klucze w pliku konfiguracyjnym pakietu WWW:<br />

        • test property określa, który plik lub pliki należy przekształcić.<br />
        • use property wskazuje, który moduł ładujący powinien zostać użyty do transformacji.
    </h3>
    <h3>
        Poniższa konfiguracja definiuje rules property. To mówi webpackowi, aby szukał plików z rozszerzeniem .txt
        rozszerzenie i użyć modułu ładującego raw do zaimportowania ich jako ciągu do pakietu. rules property powinna
        być zdefiniowane w module module.rules.
    </h3>
    <h3>
        Możliwość importowania dowolnego rodzaju modułu, takiego jak pliki .css, jest funkcją specyficzną dla webpack i
        mogą nie być obsługiwane przez innych producentów pakietów lub organizatorów zadań.
    </h3>
    <h2>Plugins</h2>
    <h3>
        Podczas gdy moduły ładujące są używane do przekształcania niektórych typów modułów, wtyczki mogą być wykorzystywane do wykonywania
        szerszy zakres zadań. Wtyczki obejmują zarówno optymalizację i minimalizację pakietów, jak i definiowanie
        zmienne środowiskowe. Interfejs wtyczki jest niezwykle potężny i można go używać do obsługi szerokiej gamy
        różnorodność zadań.
    </h3>
    <h4>
        W poniższym przykładzie używamy wtyczki webpack UglifyJS, aby zminimalizować JavaScript, a także webpack HTML
        wtyczki, aby znaleźć lub utworzyć plik indeksu HTML i wstawić znacznik skryptu do kodu HTML zawierającego
        odniesienie do pliku pakietu.
    </h4>
    <textarea rows="21" cols="80">
const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
const webpack = require('webpack'); //to access built-in plugins
const path = require('path');
module.exports = {
entry: './path/to/my/entry/file.js',
output: {
path: path.resolve(__dirname, 'dist'),
filename: 'my-first-webpack.bundle.js'
},
module: {
rules: [
{ test: /\.txt$/, use: 'raw-loader' }
]
},
plugins: [
new webpack.optimize.UglifyJsPlugin(),
new HtmlWebpackPlugin({template: './src/index.html'})
]
};
</textarea>
    <hr />
    <h1>Babel concepts and configuration</h1>
    <h3>
        Babel rozwiązuje problem braku przeglądarki i
        obsługa platformy (np. węzła) dla najbardziej aktualnych
        Funkcje daty standardu ECMAScript.
        Programiści zawsze chcą korzystać z najnowocześniejszych
        funkcje w kodzie, ale zajmuje to trochę czasu
        przeglądarki obsługujące te funkcje i aktualizujące
        ich wersje.
    </h3>
    <h3>
        Babel pobiera napisany kod JavaScript
        zgodnie z najnowszym standardem i transponuje go
        (konwersja z jednego języka kodowego na inny)
        do kodu zgodnego ze starszymi standardami.
    </h3>
    <h3>
        W wielu przypadkach Babel musi dodać fragmenty kodu
        które naśladują działanie linii kodu zapisanych w nowym standardzie. Te fragmenty kodu, które naśladują
        możliwości innowacyjnego kodu nazywane są polyfills.
    </h3>
    <h2>Babel Polyfills</h2>
    <h3>
        Niektóre funkcje w ES6 nie są wystarczające
        przekonwertować je na inny kod. W niektórych przypadkach tak jest
        konieczne, aby utworzyć odpowiedni obiekt, ponieważ
        obiekt nie istnieje w wersji przeglądarki.
        Jeśli spróbujemy skompilować kod, który obejmuje
        przedmiot promise, widzimy, że promise
        obiekt nie zmienia się z transpilerem Babel. To
        ponieważ Babel zakłada, że ​​mamy globalny
        obiekt o nazwie Promise.
    </h3>
    <h4>Poniższy przykład kodu pokazuje, jak skompilować obiekt promise ES6 z Babel:</h4>
    <textarea rows="45" cols="80">
ES6 Code
let promise = new Promise((resolve, reject) => {
let request = new XMLHttpRequest();
request.open('GET', 'some REST api');
request.onload = function() {
if (request.status == 200) {
resolve(request.response);
} else {
reject(Error(request.statusText));
}
};
request.send(); //send the request
});
let success = (data) => {
console.log('success');
}
let error = (error) => {
console.log('error');
}
myPromise.then(success,error)
ES5 Code
'use strict';
var promise = new Promise(function (resolve, reject) {
var request = new XMLHttpRequest();
request.open('GET', 'some REST api');
request.onload = function () {
if (request.status == 200) {
resolve(request.response);
} else {
reject(Error(request.statusText));
}
};
request.send(); //send the request
});
var success = function success(data) {
console.log('success');
};
var error = function error(_error) {
console.log('error');
};
myPromise.then(success, error);
</textarea>
    <h3>
        Jak widać z przykładu kodu, obiekt promise nie zmienia się. W takim przypadku musimy użyć
        polyfill Babel. Polyfill to po prostu fragment kodu w JavaScript, który symuluje nieodłączną funkcję w
        przestarzałe przeglądarki. Polifill Promise sprawdza, czy istnieje globalny obiekt Promise. Jeśli nie istnieje, to
        tworzy globalny obiekt Promise i wprowadza w nim wszystkie funkcje, które powinny tam być. Na przykład,
        rozwiązywanie, a następnie odrzucanie metod, wszystko w standardowym ES5. Tak więc przeglądarki lub środowiska, które nawet nie wiedzą
        ES6 wie, co z tym zrobić.
    </h3>
</body>
</html>